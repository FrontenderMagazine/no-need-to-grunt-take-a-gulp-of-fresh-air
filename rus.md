На днях состоялся релиз Gulp(*англ. «глоток»*), достойной альтернативы 
сверхпопулярному JavaScript таск-менеджеру Grunt. Давайте попробуем разобраться,
зачем был создан gulp, и что отличает его от Grunt.

Когда дело доходит до JavaScript таск-менеджеров, Grunt — царь. Ну, по крайней 
мере, еще недавно было так… Ранее, в этом году, команда на [Fractal][1] 
[выразила свое отношение][2] к Grunt, и выступила с идеей взять все великие идеи
и преимущества Grunt, и воссоздать их. Они назвали свой проект [gulp][3].
И, хотя, он решает те же проблемы, что и Grunt, под капотом у них очень большие
различия. И так…


## Что такое «таск-менеджер»

Некоторые из вас могут быть знакомы с Grunt, некоторые — нет. Для несведущих,
немного проясним, что же такое JavaScript таск-менеджер.

Таск-менеджер — небольшое приложение, которое используется для автоматизации
занудных отнимающих время задач, которые приходится постоянно выполнять 
в процессе разработки проекта. Такие задачи включают в себя, к примеру, запуск
тестов, конкатенацию файлов, минификацию, препроцессинг CSS. Просто создав
таск-файл, вы можете проинструктировать таск-менеджер, как выполнить практически
любую задачу. После этого вы можете заняться делом. Это очень простая идея,
которая позволяет сохранить очень много времени, и помогает держать фокус
на разработке.


## Различия

Теперь, когда мы находимся на одном уровне, вы можете спросить: «Чем
gulp отличается от Grunt, и почему это так тебя беспокоит?»


### Потоки

Gulp основан на *потоках*. Здесь я хотел бы углубиться объяснение устройства
потоков, но уже [есть замечательный источник][4], где, если вам конечно интересно,
вы можете выяснить что такое потоки.

Если не вдаваться в подробности, потоки дают вам больше контроля над происходящим
и избавляют вас от промежуточных папок и файлов. Вы передаете файл в gulp, а
затем сохраняете результат. Это очень просто.


### Плагины

Когда дело доходит до расширения функциональности, gulp верит, что каждый 
плагин должен выполнять только *одно простое действие*. Gulp же просто
соединяет и организует эти действия в задачи. Здесь нет общих плагинов или
плагинов, конфликтующих с ядром или между собой.


### Code Not Config

Мне лично больше всего нравится то, что gulpfile — это код, а не *конфиг*. Gulp
следует спецификации CommonJS, и если вы знакомы с Node, у вас не возникнет 
никаких проблем. Gulpfile выглядит аккуратно и читаемо, и его написание
не должно вызвать никаких затруднений, потому как струкрутирован код уже
известным способом.


## Примеры

Все это трудно осмыслить без кода, так что я покажу вам два примера. Ниже, мы
создадим gruntfile и gulpfile. Оба они будут делать линтинг, конкатенацию
и минификацию js-файлов в нашем проекте. Также, при изменениях в наших файлах
оба таск-менеджера должны выплнять связанные с этими файлами задачи повторно.

Начнем с gruntfile, а затем я покажу вам, как то же самое выглядит в gulpfile.
Это поможет вам понять, как работают оба таск-менеджера, и как именно gulp
развил идеи Grunt.


#### gruntfile.js

    module.exports = function(grunt) {
      grunt.initConfig({
        pkg: grunt.file.readJSON('package.json'),
        concat: {
          options: {
            separator: ';'
          },
          dist: {
            src: ['src/**/*.js'],
            dest: 'dist/<%= pkg.name %>.js'
          }
        },
        uglify: {
          dist: {
            files: {
              'dist/<%= pkg.name %>.min.js': ['<%= concat.dist.dest %>']
            }
          }
        },
        jshint: {
          files: ['gruntfile.js', 'src/**/*.js', 'test/**/*.js'],
          options: {
            globals: {
              jQuery: true,
              console: true,
              module: true,
              document: true
            }
          }
        },
        watch: {
          files: ['<%= jshint.files =>'],
          tasks: ['jshint', 'concat', 'uglify']
        }
      });
    
      // Load Our Plugins
      grunt.loadNpmTasks('grunt-contrib-jshint');
      grunt.loadNpmTasks('grunt-contrib-concat');
      grunt.loadNpmTasks('grunt-contrib-uglify');
      grunt.loadNpmTasks('grunt-contrib-watch');
    
      // Register Default Task
      grunt.registerTask('default', ['jshint', 'concat', 'uglify']);
    
    };
    
    

#### gulpfile.js

    var gulp = require('gulp');
    var jshint = require('gulp-jshint');
    var concat = require('gulp-concat');
    var rename = require('gulp-rename');
    var uglify = require('gulp-uglify');
    
    // Lint JS
    gulp.task('lint', function() {
      gulp.src('./src/*.js')
        .pipe(jshint())
        .pipe(jshint.reporter('default'));
    });
    
    // Concat & Minify JS
    gulp.task('minify', function(){
        gulp.src('./src/*.js')
            .pipe(concat('all.js'))
            .pipe(gulp.dest('./dist'))
            .pipe(rename('all.min.js'))
            .pipe(uglify())
            .pipe(gulp.dest('./dist'));
    });
    
    // Default
    gulp.task('default', function(){
      gulp.run('lint', 'minify');
    
      // Watch JS Files
      gulp.watch("./src/*.js", function(event){
        gulp.run('lint', 'minify');
      });
    });
    

Используя gulp, мы уменьшили количество строк в нашем коде с 52 до 30. Очевидно,
вы заметите, что хотя нам потребовалось одинаковое количество плагинов, два плагина
различаются, несмотря на то, что мы выполняем совершенно одинаковую задачу. Это
еще больше иллюстрирует основополагающее различие в плагинах, о котором я писал выше.

В gulp нет необходимости в плагине `watch`, потому как это возможность следить 
за изменениями в файлах уже включена в ядро. Это возможность нужна вам по умолчанию,
а не посредством помощью плагина.

В дополнение, переименование файла в Grunt выполняется с помощью плагина `uglify`.
Выходит, что один и тот же плагин отвечает как за минификацию кода, так и за
переименование файла, полученного в результате минификации. В gulp же каждый
плагин выполняет одно простое действие, и отвечает только за него. Для
переименования файла мы просто подключим плагин `gulp-rename` и добавим его
в нашу задачу по минификации кода.


## Вывод

В конечном счете, все можно свести к личным предпочтениям. Лично я предпочитаю
«node-подобный» путь в написании моих таск-файлов с gulp, но все же я должен
сказать, что я действительно рад тому времени, которое я провел с Grunt. Очень
важно не просто понимать, как устроены оба таск-менеджера, но и понимать какими
решениями руководстововались разработчики этих инструментов, и почему эти
решения были приняты. Такой подход поможет вам узнать много всего нового, 
и сэкономит вам массу времени в разработке. Чтож, если вы готовы начать — вперед, 
[на GitHib за gulp][3].


## Дополнительные материалы

*   [Настольная книга о потоках][5]
*   [Слайды о gulp][2]
*   [gulp на Github][3]

 [1]: http://wearefractal.com "Fractal"
 [2]: http://slid.es/contra/gulp "gulp slideshow on slid.es"
 [3]: https://github.com/wearefractal/gulp "gulp on Github"
 [4]: https://github.com/substack/stream-handbook
 [5]: https://github.com/substack/stream-handbook "Stream Handbook on Github"