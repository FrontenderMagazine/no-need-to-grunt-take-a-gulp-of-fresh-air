На днях состоялся релиз gulp (*с англ. «глоток»*), достойной альтернативы очень
популярному JavaScript таск-менеджеру GruntJS. Давайте разберемся, что же
отличает их друго от друга, и попытаемся понять, зачем был создан gulp.

Когда дело доходит до JavaScript таск-менеджеров, Grunt — царь. Ну, по крайней 
мере, раньше было так… Ранее, в этом году, команда на [Fractal][1] 
[выразила свое отношение][2] к Grunt, и выступила с идеей взять все великие идеи
и преимущества Grunt, и воссоздать их. Они назвали свой проект [gulp][3](глоток).
И, хотя, он решает те же проблемы, что и Grunt, под капотом у них очень большие
различия. И так…


## Что такое «таск-менеджер»

Некоторые из вас могут быть знакомы с Grunt, некоторые — нет. Для несведущих,
давайте немного проясним, что же такое JavaScript таск-менеджер.

Таск-менеджер — это небольшое приложение, которое используется для автоматизации
занудных, отнимающих время задач, которые приходится делать в процессе разработки
проекта. Такие задачи включают в себя запуск тестов, конкатенацию файлов, 
минификацию, препроцессинг CSS. Просто создав таск-файл, вы можете
проинструктировать таск-менеджер, как выполнить практически любую задачу. После
этого вы можете заняться делом. Это очень простая идея, которая позволяет
сохранить очень много времени, и помогает держать фокус на разработке.


## Различия

Теперь, когда мы находимся на одном уровне, вы можете спросить: «Чем
gulp отличается от Grunt, и почему это меня должно меня беспокоить?»


### Потоки

Gulp *потоковая* система сборки. Здесь я хотел бы углубиться объяснение устройства
потоков, но [вот замечательный источник][4], где, если вам интересно, вы можете
выяснить что такое потоки.

Если не усложнять, потоки дают вам больше контроля над происходящим и избавляют
вас от промежуточных папок и файлов. Вы передаете файл в gulp, а затем сохраняете
результат. Это очень просто.


### Плагины

Когда дело доходит до расширения функциональности, gulp верит, что каждый 
плагин должен выполнять только *одно простое действие*. Gulp же просто
соединяет и организует их. Здесь нет общих плагинов или плагинов, конфликтующих
с другими плагинами или ядром.

### Code Not Config

Больше всего лично мне нравится, что gulpfile — это код, а не *конфиг*. С тех
пор как gulp следует спецификации CommonJS, если вы знакомы с Node, вы будете
чувствовать себя как дома. Все это выглядит аккуратно и читаемо, и, потому как
все структурированно знакомым способом, то написать gulpfile не составит никаких
затруднений.


## Примеры

Все это трудно оценить без кода. Так что я покажу вам пару примеров. В следующих
фрагментах кода мы создадим gruntfile и gulpfile, которые будут делать линтинг,
конкатенацию и минификацию js-файлов в нашем проекте. Затем мы запустим оба, 
для того, чтобы они наблюдали за файлами, и выполняли задачи заново при изменениях.

Начнем с grungfile, и затем я покажу вам, как выглядит то же самое в gulpfile.
Это поможет вам понять, как все работает вместе и как gulp развил идеи Grunt.

#### gruntfile.js

    module.exports = function(grunt) {
      grunt.initConfig({
        pkg: grunt.file.readJSON('package.json'),
        concat: {
          options: {
            separator: ';'
          },
          dist: {
            src: ['src/**/*.js'],
            dest: 'dist/<%= pkg.name %>.js'
          }
        },
        uglify: {
          dist: {
            files: {
              'dist/<%= pkg.name %>.min.js': ['<%= concat.dist.dest %>']
            }
          }
        },
        jshint: {
          files: ['gruntfile.js', 'src/**/*.js', 'test/**/*.js'],
          options: {
            globals: {
              jQuery: true,
              console: true,
              module: true,
              document: true
            }
          }
        },
        watch: {
          files: ['<%= jshint.files =>'],
          tasks: ['jshint', 'concat', 'uglify']
        }
      });
    
      // Load Our Plugins
      grunt.loadNpmTasks('grunt-contrib-jshint');
      grunt.loadNpmTasks('grunt-contrib-concat');
      grunt.loadNpmTasks('grunt-contrib-uglify');
      grunt.loadNpmTasks('grunt-contrib-watch');
    
      // Register Default Task
      grunt.registerTask('default', ['jshint', 'concat', 'uglify']);
    
    };
    
    

#### gulpfile.js

    var gulp = require('gulp');
    var jshint = require('gulp-jshint');
    var concat = require('gulp-concat');
    var rename = require('gulp-rename');
    var uglify = require('gulp-uglify');
    
    // Lint JS
    gulp.task('lint', function() {
      gulp.src('./src/*.js')
        .pipe(jshint())
        .pipe(jshint.reporter('default'));
    });
    
    // Concat & Minify JS
    gulp.task('minify', function(){
        gulp.src('./src/*.js')
            .pipe(concat('all.js'))
            .pipe(gulp.dest('./dist'))
            .pipe(rename('all.min.js'))
            .pipe(uglify())
            .pipe(gulp.dest('./dist'));
    });
    
    // Default
    gulp.task('default', function(){
      gulp.run('lint', 'minify');
    
      // Watch JS Files
      gulp.watch("./src/*.js", function(event){
        gulp.run('lint', 'minify');
      });
    });
    

Переключившись на gulp, мы уменьшили наш код с 52 строк до 30. Очевидно, вы 
заметите, что нам требуется то же количество плагинов, но 2 из них различаются,
несмотря на то, что мы выполняем совершенно одинаковую задачу. Это еще больше
иллюстрирует основополагающее различие в плагинах, о котором я писал выше.

С gulp нам не требуется подключать `watch`, потому как это возможность следить 
за изменениями в файлах включена в ядро. Это возможность, которая вам нужна
по умолчанию, а не с помощью плагина.

В дополнение, переименование файла в Grunt выполняется с помощью плагина `uglify`.
Один и тот же плагин отвечает за минификацию кода, И за переименование файла,
полученного в результате. В gulp же каждый плагин выполняет одно простое действие,
и отвечает только за него. Для переименования файла мы просто подключим плагин 
`gulp-rename` и добавим его в нашу задачу по минификации кода.


## Conclusion

В конечном счете, все можно свести к личным предпочтениям. Лично я предпочитаю
«node-подобный» путь в написании моих таск-файлов с gulp, но я должен сказать, 
что так же я действительно рад тому времени, которое я провел с Grunt. Очень
важно не просто понимать, как устроены оба таск-менеджера, но и понимать какими
решениями руководстововались команды, которые разрабатывали эти инструменты,
и почему они эти решения приняли. Это поможет вам узнать много всего нового, 
и сэкономит вам много времени в разработке. Если вы готовы начать — вперед, 
[на GitHib за gulp][3].


## Дополнительные материалы

*   [Настольная книга о потоках][5]
*   [Слайды о gulp][2]
*   [gulp на Github][3]

 [1]: http://wearefractal.com "Fractal"
 [2]: http://slid.es/contra/gulp "gulp slideshow on slid.es"
 [3]: https://github.com/wearefractal/gulp "gulp on Github"
 [4]: https://github.com/substack/stream-handbook
 [5]: https://github.com/substack/stream-handbook "Stream Handbook on Github"